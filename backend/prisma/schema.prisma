generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  DOCTOR
  PATIENT
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum BookingStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum NotificationType {
  BOOKING_STATUS
  CHAT_MESSAGE
  SYSTEM
}

model User {
  id                  String    @id @default(uuid())
  email               String    @unique
  password            String?
  firstName           String
  lastName            String
  phone               String?
  avatar              String?
  role                Role      @default(PATIENT)
  gender              Gender?
  dateOfBirth         DateTime?
  bio                 String?

  specialty           String?
  licenseNumber       String?
  licenseDocument     String?
  consultationFee     Float?
  affiliation         String?
  yearsOfExperience   Int?
  clinicAddress       String?
  clinicContactPerson String?
  clinicPhone         String?

  @@index([role])
  @@index([specialty])
  @@index([isActive])
  @@index([isVerified])
  @@index([email])
  isVerified          Boolean   @default(false)

  isActive            Boolean   @default(true)
  isEmailVerified     Boolean   @default(false)

  isTwoFactorEnabled  Boolean   @default(false)
  twoFactorSecret     String?

  googleId            String?   @unique

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  lastLoginAt         DateTime?

  refreshTokens       RefreshToken[]
  passwordResets      PasswordReset[]
  availabilities      Availability[] @relation("DoctorAvailability")
  bookingsAsDoctor    Booking[]      @relation("DoctorBookings")
  bookingsAsPatient   Booking[]      @relation("PatientBookings")
  sentMessages        Message[]      @relation("SentMessages")
  receivedMessages    Message[]      @relation("ReceivedMessages")

  notifications       Notification[]

  @@map("users")
}

model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@map("refresh_tokens")
}

model PasswordReset {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  used        Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@map("password_resets")
}

model Availability {
  id        String   @id @default(uuid())
  date      String
  startTime String
  endTime   String
  doctorId  String
  doctor    User     @relation("DoctorAvailability", fields: [doctorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("availabilities")
}

model Booking {
  id        String   @id @default(uuid())
  date      String
  startTime String
  endTime   String
  duration  Int
  status    BookingStatus
  doctorId  String
  patientId String
  doctor    User     @relation("DoctorBookings", fields: [doctorId], references: [id])
  patient   User     @relation("PatientBookings", fields: [patientId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  messages  Message[]

  @@map("bookings")
}

model Message {
  id         String   @id @default(uuid())
  content    String
  isRead     Boolean  @default(false)
  bookingId  String
  senderId   String
  receiverId String
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  sender     User     @relation("SentMessages", fields: [senderId], references: [id])
  receiver   User     @relation("ReceivedMessages", fields: [receiverId], references: [id])
  createdAt  DateTime @default(now())

  @@index([bookingId])
  @@index([senderId, receiverId])
  @@map("messages")
}

model Notification {
  id        String           @id @default(uuid())

  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  type      NotificationType
  title     String
  body      String
  data      Json?

  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())

  @@index([userId, isRead, createdAt])
  @@map("notifications")
}
