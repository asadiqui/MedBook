generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  DOCTOR
  PATIENT
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum BookingStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum NotificationType {
  BOOKING_STATUS
  CHAT_MESSAGE
  SYSTEM
}

model User {
  id                  String    @id @default(uuid())
  email               String    @unique
  password            String?
  firstName           String
  lastName            String
  phone               String?
  avatar              String?
  role                Role      @default(PATIENT)
  gender              Gender?
  dateOfBirth         DateTime?
  bio                 String?
  
  // Doctor-specific fields
  specialty           String?
  licenseNumber       String?
  licenseDocument     String?   // Uploaded license/certification file path
  consultationFee     Float?
  affiliation         String?   // Current Affiliation (Clinic/Hospital Name)
  yearsOfExperience   Int?
  clinicAddress       String?
  clinicContactPerson String?
  clinicPhone         String?

  @@index([role])
  @@index([specialty])
  @@index([isActive])
  @@index([isVerified])
  @@index([email])
  isVerified          Boolean   @default(false)
  
  // Account status
  isActive            Boolean   @default(true)
  isEmailVerified     Boolean   @default(false)
  
  // Two-factor authentication
  isTwoFactorEnabled  Boolean   @default(false)
  twoFactorSecret     String?
  
  // OAuth
  googleId            String?   @unique
  
  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  lastLoginAt         DateTime?
  
  // Relations
  refreshTokens       RefreshToken[]
  passwordResets      PasswordReset[]
  availabilities      Availability[] @relation("DoctorAvailability")
  bookingsAsDoctor    Booking[]      @relation("DoctorBookings")
  bookingsAsPatient   Booking[]      @relation("PatientBookings")
  sentMessages        Message[]      @relation("SentMessages")
  receivedMessages    Message[]      @relation("ReceivedMessages")
  aiMessages          AiMessage[]
  aiUsage             UserAiUsage[]
  notifications       Notification[]

  @@map("users")
}

model UserAiUsage {
  id            String   @id @default(uuid())
  userId        String
  date          String   // YYYY-MM-DD
  llmTokenCount Int      @default(0)
  ragTokenCount Int      @default(0)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@map("user_ai_usage")
}

model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@map("refresh_tokens")
}

model PasswordReset {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  used        Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@map("password_resets")
}

model Availability {
  id        String   @id @default(uuid())
  date      String
  startTime String
  endTime   String
  doctorId  String
  doctor    User     @relation("DoctorAvailability", fields: [doctorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("availabilities")
}

model Booking {
  id        String   @id @default(uuid())
  date      String
  startTime String
  endTime   String
  duration  Int
  status    BookingStatus
  doctorId  String
  patientId String
  doctor    User     @relation("DoctorBookings", fields: [doctorId], references: [id])
  patient   User     @relation("PatientBookings", fields: [patientId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  messages  Message[]

  @@map("bookings")
}

model Message {
  id         String   @id @default(uuid())
  content    String
  isRead     Boolean  @default(false)
  bookingId  String
  senderId   String
  receiverId String
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  sender     User     @relation("SentMessages", fields: [senderId], references: [id])
  receiver   User     @relation("ReceivedMessages", fields: [receiverId], references: [id])
  createdAt  DateTime @default(now())

  @@index([bookingId])
  @@index([senderId, receiverId])
  @@map("messages")
}

model AiMessage {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  agentId   String
  role      String
  content   String   @db.Text
  createdAt DateTime @default(now())

  @@index([userId, agentId])
  @@map("ai_messages")
}

model Notification {
  id        String           @id @default(uuid())

  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  type      NotificationType
  title     String
  body      String
  data      Json?

  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())

  @@index([userId, isRead, createdAt])
  @@map("notifications")
}

model Document {
  id        String                 @id @default(uuid())
  content   String
  source    String
  embedding Unsupported("vector")?

  @@map("documents")
}
