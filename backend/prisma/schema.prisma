generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  DOCTOR
  PATIENT
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum BookingStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum NotificationType {
  BOOKING_CREATED
  BOOKING_ACCEPTED
  BOOKING_REJECTED
  BOOKING_CANCELLED
}

model User {
  id                  String    @id @default(uuid())
  email               String    @unique
  password            String?
  firstName           String
  lastName            String
  phone               String?
  avatar              String?
  role                Role      @default(PATIENT)
  gender              Gender?
  dateOfBirth         DateTime?
  bio                 String?

  specialty           String?
  licenseNumber       String?
  licenseDocument     String?
  consultationFee     Float?
  affiliation         String?
  yearsOfExperience   Int?
  clinicAddress       String?
  clinicContactPerson String?
  clinicPhone         String?
  isVerified          Boolean   @default(false)

  isActive            Boolean   @default(true)
  isEmailVerified     Boolean   @default(false)

  isTwoFactorEnabled  Boolean   @default(false)
  twoFactorSecret     String?

  googleId            String?   @unique

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  lastLoginAt         DateTime?

  refreshTokens       RefreshToken[]
  passwordResets      PasswordReset[]
  availabilities      Availability[] @relation("DoctorAvailability")
  bookingsAsDoctor    Booking[]      @relation("DoctorBookings")
  bookingsAsPatient   Booking[]      @relation("PatientBookings")
  sentMessages        Message[]      @relation("SentMessages")
  receivedMessages    Message[]      @relation("ReceivedMessages")
  notifications Notification[] @relation("UserNotifications")

  @@map("users")
}

model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@map("refresh_tokens")
}

model PasswordReset {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  used        Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@map("password_resets")
}

model Availability {
  id        String   @id @default(uuid())
  date      String
  startTime String
  endTime   String
  doctorId  String
  doctor    User     @relation("DoctorAvailability", fields: [doctorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("availabilities")
}

model Booking {
  id        String   @id @default(uuid())
  date      String
  startTime String
  endTime   String
  duration  Int
  status    BookingStatus
  doctorId  String
  patientId String
  doctor    User     @relation("DoctorBookings", fields: [doctorId], references: [id])
  patient   User     @relation("PatientBookings", fields: [patientId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  messages  Message[]
  notifications Notification[]

  @@map("bookings")
}

model Message {
  id        String   @id @default(uuid())
  content   String
  isRead    Boolean  @default(false)
  bookingId String
  senderId  String
  receiverId String
  booking   Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  sender    User     @relation("SentMessages", fields: [senderId], references: [id])
  receiver  User     @relation("ReceivedMessages", fields: [receiverId], references: [id])
  createdAt DateTime @default(now())

  @@index([bookingId])
  @@index([senderId, receiverId])
  @@map("messages")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String           // Who should receive this notification
  type      NotificationType // What type of notification (BOOKING_CREATED, etc.)
  title     String           // Short title like "New Booking Request"
  message   String           // The actual message text
  isRead    Boolean          @default(false) // Has the user seen it?
  bookingId String?          // Optional: link to booking if related
  booking   Booking?         @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  user      User             @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime         @default(now())
  readAt    DateTime?        // When did they read it? (optional)

  @@index([userId, isRead])  // Makes searching faster
  @@map("notifications")
}